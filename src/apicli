#!/usr/bin/env bun
import fs from 'node:fs';
import { fileURLToPath } from 'node:url';
import { dirname, join, resolve } from 'node:path';
import { fetchApi, fetchWS, getApi, getApis, getFlow } from './fetch.js';
import { homedir } from 'node:os';
import { parseYaml, stringifyYaml } from './yaml.js';

const root = join(dirname(fileURLToPath(import.meta.url)), '..');
const userDir = join(homedir(), '.apicli');
const userYamlPath = join(userDir, 'apicli.yaml');
const userTxtPath = join(userDir, 'apis.txt');

try {
  if (!fs.existsSync(userDir)) fs.mkdirSync(userDir, { recursive: true });
} catch {}
if (!fs.existsSync(userYamlPath) && !fs.existsSync(userTxtPath)) {
  const defaultPath = join(root, 'apicli.yaml');
  if (fs.existsSync(defaultPath)) {
    try {
      fs.copyFileSync(defaultPath, userYamlPath);
      try { fs.unlinkSync(defaultPath); } catch {}
    } catch {}
  }
}

const c = { dim: '\x1b[90m', cyan: '\x1b[36m', yellow: '\x1b[33m', green: '\x1b[32m', bold: '\x1b[1m', reset: '\x1b[0m' };

const usage = `
ðŸ”Œ ${c.bold}apicli${c.reset} ${c.dim}â€” call APIs (${c.cyan}./apicli${c.reset})${c.reset}

${c.bold}Commands${c.reset}
  ${c.cyan}ls|list${c.reset} [pattern]       List APIs (e.g. ${c.dim}apicli list "openrouter"${c.reset})
  ${c.cyan}fetch${c.reset} <name>            Copy API definition to ${c.dim}./apicli.yaml${c.reset}
  ${c.cyan}help${c.reset} <pattern>          Show matching lines (e.g. ${c.dim}apicli help "httpbin*"${c.reset})
  ${c.green}<service.name>${c.reset} [k=v â€¦]  Call API with optional params

${c.bold}Options${c.reset}
  ${c.cyan}-time${c.reset}                   Print request duration
  ${c.cyan}-debug${c.reset}                  Print fetch request/response info (e.g. ${c.dim}apicli -debug httpbin.get${c.reset})
  ${c.cyan}-config${c.reset} <path>          Use custom config file (e.g. ${c.dim}apicli -config ./custom.yaml httpbin.get${c.reset})

${c.bold}Example${c.reset}
  ${c.dim}apicli openrouter.chat API_KEY=$OPENROUTER_API_KEY MODEL=openai/gpt-4o-mini PROMPT=Hello${c.reset}
  ${c.dim}apicli -time httpbin.get${c.reset}
  ${c.dim}apicli -debug httpbin.get${c.reset}
`;

const rawArgs = process.argv.slice(2);
const timeFlag = rawArgs.includes('-time') || rawArgs.includes('--time');
const debugFlag = rawArgs.includes('-debug') || rawArgs.includes('--debug');
const configIdx = rawArgs.findIndex(a => a === '-config' || a === '--config');
if (configIdx >= 0 && (!rawArgs[configIdx + 1] || rawArgs[configIdx + 1].startsWith('-'))) {
  console.error('Error: -config requires a file path');
  process.exit(1);
}
const configPath = configIdx >= 0 ? rawArgs[configIdx + 1] : null;
const args = rawArgs.filter((a, i) => {
  if (['-time', '--time', '-debug', '--debug'].includes(a)) return false;
  if (configIdx >= 0 && (i === configIdx || i === configIdx + 1)) return false;
  return true;
});
const arg = args[0];
const pattern = args[1] ?? '.';
const cleanApiDefinition = (a) => {
  const { id, service, name, base, step, ...rest } = a;
  return rest;
};

const userConfigPath = () => [userYamlPath, userTxtPath].find(fs.existsSync);
const defaultConfigPath = () => {
  const bundled = join(root, 'apicli.yaml');
  return fs.existsSync(bundled) ? bundled : null;
};
const resolveConfigPath = (override) => override ?? userConfigPath() ?? defaultConfigPath();
const printConfigInfo = () => {
  const p = resolveConfigPath(configPath);
  if (p) console.error(configPath ? 'config:' : 'user:   ', p);
};
const getConfigFiles = (override) => {
  const p = resolveConfigPath(override);
  return p ? [p] : [];
};
const searchConfig = (re) => {
  for (const f of getConfigFiles(configPath)) {
    if (!fs.existsSync(f)) continue;
    for (const line of fs.readFileSync(f, 'utf8').split('\n')) {
      if (re.test(line)) console.log(line);
    }
  }
};

const showConfigInfo = args.length === 0;
if (showConfigInfo) printConfigInfo();

if (!arg || arg === '-h' || arg === '--help') {
  console.log(usage);
  process.exit(0);
}

if (arg === 'ls' || arg === 'list') {
  const p = resolveConfigPath(configPath);
  const re = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
  for (const a of getApis(p)) {
    const id = a.id ?? `${a.service}.${a.name}`;
    if (re.test(id)) console.log(id);
  }
  process.exit(0);
}

if (arg === 'help') {
  const re = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
  searchConfig(re);
  process.exit(0);
}

if (arg === 'fetch') {
  const p = resolveConfigPath(configPath);
  const name = args[1];
  if (!name) {
    console.error('Error: fetch requires an API name (e.g. openai.chat)');
    process.exit(1);
  }
  const match = getApis(p).find(a => a.id === name);
  if (!match) {
    console.error('Unknown API:', name);
    process.exit(1);
  }
  const outPath = resolve(process.cwd(), 'apicli.yaml');
  let outDoc = {};
  if (fs.existsSync(outPath)) {
    try {
      const parsed = parseYaml(fs.readFileSync(outPath, 'utf8'));
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) outDoc = parsed;
    } catch (err) {
      console.error(`Invalid YAML in ${outPath}: ${err.message}`);
      process.exit(1);
    }
  }
  outDoc[name] = cleanApiDefinition(match);
  fs.writeFileSync(outPath, stringifyYaml(outDoc), 'utf8');
  console.log(name);
  process.exit(0);
}

if (/^\w+\.\w+$/.test(arg)) {
  const p = resolveConfigPath(configPath);
  const [service, name] = arg.split('.');
  const { base, steps } = getFlow(service, name, p);
  const api = base ?? getApi(service, name, p);
  if (!api && steps.length === 0) {
    console.error('Unknown API:', arg);
    process.exit(1);
  }
  const params = {};
  for (const a of args.slice(1)) {
    const i = a.indexOf('=');
    if (i > 0) params[a.slice(0, i)] = a.slice(i + 1);
  }
  const isWs = steps.length > 0 || (api?.url && String(api.url).startsWith('ws'));
  const hasBodyTemplate = api?.body != null && String(api.body).trim() !== '';
  const isJsonPost = api?.method === 'POST' && (() => {
    if (!api.headers) return false;
    if (typeof api.headers === 'string') {
      const h = api.headers.toLowerCase();
      return h.includes('json') || h.startsWith('bearer ');
    }
    if (typeof api.headers === 'object') {
      const ct = Object.entries(api.headers).find(([k]) => k.toLowerCase() === 'content-type')?.[1];
      return typeof ct === 'string' && ct.toLowerCase().includes('json');
    }
    return false;
  })();
  const overrides = isWs
    ? { vars: params, configPath: p }
    : hasBodyTemplate
      ? { vars: params, configPath: p }
      : isJsonPost
        ? { body: JSON.stringify(params), configPath: p }
        : { vars: params, configPath: p };
  if (debugFlag) overrides.debug = true;
  try {
    const t0 = timeFlag ? process.hrtime.bigint() : null;
    if (isWs) {
      await fetchWS(service, name, { ...overrides, onMessage: (_msg, ctx) => console.log(ctx.raw) });
      if (t0 != null) {
        const ms = Number(process.hrtime.bigint() - t0) / 1e6;
        console.error(`\x1b[90m%ims\x1b[0m`, ms.toFixed(0));
      }
    } else {
      const response = await fetchApi(service, name, overrides);
      const result = await response.json();
      if (t0 != null) {
        const ms = Number(process.hrtime.bigint() - t0) / 1e6;
        console.error(`\x1b[90m%ims\x1b[0m`, ms.toFixed(0));
      }
      console.log(JSON.stringify(result, null, 2));
    }
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
  process.exit(0);
}

// search apicli.yaml/apis.txt
const re2 = new RegExp(arg.replace(/\*/g, '.*'), 'i');
searchConfig(re2);
